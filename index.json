[{"categories":["guide","notes"],"content":"O CMakeConfig.txt é um arquivo de configuração utilizado pelo CMake para definir como um projeto deve ser construído, incluindo definições de variáveis, opções de compilação, diretórios de inclusão e outras configurações necessárias. É uma boa escolha especialmente para fazer projetos multiplataforma em C/C++. ","date":"2024-05-23","objectID":"/posts/utilizando-o-cmake/:0:0","series":null,"tags":["C++"],"title":"Utilizando o CMake","uri":"/posts/utilizando-o-cmake/#"},{"categories":["guide","notes"],"content":" Criando um projeto com o CMakeO primeiro passo para criar um projeto utilizando o CMake é criando um arquivo CMakeConfig.txt na raiz do projeto. txt cmake_minimum_required(VERSION 3.8) project(\"Program\") add_executable(${PROJECT_NAME} main.cpp) Agora vamos criar um arquivo main.cpp c++ #include \u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } ","date":"2024-05-23","objectID":"/posts/utilizando-o-cmake/:1:0","series":null,"tags":["C++"],"title":"Utilizando o CMake","uri":"/posts/utilizando-o-cmake/#criando-um-projeto-com-o-cmake"},{"categories":["guide","notes"],"content":" ConfiguraçãoO CMake usa um processo chamado “configuração” para criar todos os arquivos necessários para compilar um projeto. Durante essa fase, ele lê as configurações do projeto (normalmente do arquivo CMakeLists.txt) e ajusta tudo conforme o gerador escolhido pelo usuário, como makefiles para o GNU Make ou projetos para o Visual Studio. Isso garante que o projeto seja configurado corretamente para o sistema e ferramentas de desenvolvimento usados, facilitando a compilação e gerenciamento das dependências. Vamos gerar uma configuração pro nosso projeto: shell $ cmake -B build/ -G \"Visual Studio 17 2022\" . -B \u003cdiretório\u003e : Diretório que os arquivos de build serão colocados. -G \u003cgerador\u003e : Gerador alvo que serão feitas os arquivos de projeto, como por exemplo “Visual Studio 17 2022” para windows ou “Unix Makefiles” para linux. Você pode consultar todos os geradores disponíveis através do comando cmake --help. Caso não definida essa flag, um gerador padrão definido pelo CMake será utilizado. . : Diretório onde está o CMakeConfig.txt ","date":"2024-05-23","objectID":"/posts/utilizando-o-cmake/:1:1","series":null,"tags":["C++"],"title":"Utilizando o CMake","uri":"/posts/utilizando-o-cmake/#configuração"},{"categories":["guide","notes"],"content":" CompilandoPara compilar o projeto vamos utilizar o comando: shell $ cmake --build build/ --config Debug --build \u003cdiretório\u003e : Diretório que os arquivos de build estão. --config \u003cconfig\u003e : Tipo de preset de build, como por exemplo: “Debug” ou “Release”, caso esta flag não seja especificada, o cmake utilizará o preset “Debug” por padrão. ","date":"2024-05-23","objectID":"/posts/utilizando-o-cmake/:1:2","series":null,"tags":["C++"],"title":"Utilizando o CMake","uri":"/posts/utilizando-o-cmake/#compilando"},{"categories":["notes"],"content":"Durante a compilação de um código em C++, o compilador altera os nomes das funções e símbolos no binário. Esse processo é chamado de name mangling e garante que cada símbolo tenha um identificador único. Isso é necessário, por exemplo, para suportar a sobrecarga de funções. Em C, os nomes das funções são mantidos como no código original. Para evitar essa renomeação (name mangling) em C++, utilizamos o modificador extern \"C\". Esse modificador instrui o compilador a não alterar os nomes dos símbolos, mantendo-os como no código original, o que é útil ao criar bibliotecas que precisam ser usadas em outros projetos e linguagens. ","date":"2024-05-22","objectID":"/posts/extern-c/:0:0","series":null,"tags":["C++"],"title":"Modificador extern \"C\"","uri":"/posts/extern-c/#"},{"categories":["notes"],"content":" Exemplo práticoapp.cpp c++ #include \u003ciostream\u003e #include \u003ctypeinfo\u003e #include \"c_file.h\" int main() { func(); return 0; } Ao compilar o arquivo com g++ -c app.cpp e inspecionar o binário resultante com nm app.o, observamos o seguinte: shell $ g++ -c app.cpp $ nm app.o 0000000000000000 b .bss 0000000000000000 d .data 0000000000000000 p .pdata 0000000000000000 r .rdata 0000000000000000 r .rdata$zzz 0000000000000000 t .text 0000000000000000 r .xdata U __main U _Z4funcv 0000000000000000 r _ZNSt8__detail30__integer_to_chars_is_unsignedIjEE 0000000000000001 r _ZNSt8__detail30__integer_to_chars_is_unsignedImEE 0000000000000002 r _ZNSt8__detail30__integer_to_chars_is_unsignedIyEE 0000000000000000 T main Aqui, o nome da nossa função func foi renomeado para _Z4funcv no binário. Agora, vamos modificar o código para incluir extern \"C\": c++ #include \u003ciostream\u003e #include \u003ctypeinfo\u003e extern \"C\" { #include \"c_file.h\" } int main() { func(); return 0; } Ao recompilar e inspecionar o binário novamente, veremos: shell $ g++ -c app.cpp $ nm app.o 0000000000000000 b .bss 0000000000000000 d .data 0000000000000000 p .pdata 0000000000000000 r .rdata 0000000000000000 r .rdata$zzz 0000000000000000 t .text 0000000000000000 r .xdata U __main 0000000000000000 r _ZNSt8__detail30__integer_to_chars_is_unsignedIjEE 0000000000000001 r _ZNSt8__detail30__integer_to_chars_is_unsignedImEE 0000000000000002 r _ZNSt8__detail30__integer_to_chars_is_unsignedIyEE U func 0000000000000000 T main Agora, o nome da nossa função func permanece inalterado no binário. Isso demonstra como extern \"C\" impede o name mangling, mantendo os nomes das funções como no código original. Essa técnica é especialmente útil ao escrever bibliotecas que precisam ser utilizadas em outros projetos e linguagens, garantindo a compatibilidade e a integridade dos nomes das funções. ","date":"2024-05-22","objectID":"/posts/extern-c/:1:0","series":null,"tags":["C++"],"title":"Modificador extern \"C\"","uri":"/posts/extern-c/#exemplo-prático"}]